use crate::lexer::TokenKind::*;
use crate::lexer::{IntKind, tokenize};

#[test]
fn test_valid_extra_credit_sizeof_bitwise() {
    let src = r#"
        
        int main(void) {
            static long l = 0;
            int i = 0;
            static char c = 0;
            if (sizeof (c & i) != 4) {
                return 1;
            }
            if (sizeof (i | l) != 8) {
                return 2;
            }
            if (sizeof (c ^ c) != 4) {
                return 3;
            }
            if (sizeof (i << l) != 4) {
                return 4;
            }
            if (sizeof (c << i) != 4) {
                return 5;
            }
            if (sizeof (l >> c) != 8) {
                return 6;
            }
            return 0;
        }
    "#;
    let expected = vec![
        Int,
        Identifier,
        OpenParen,
        Void,
        CloseParen,
        OpenBrace,
        Static,
        Long,
        Identifier,
        Equal,
        IntConstant(IntKind::Int),
        Semicolon,
        Int,
        Identifier,
        Equal,
        IntConstant(IntKind::Int),
        Semicolon,
        Static,
        Char,
        Identifier,
        Equal,
        IntConstant(IntKind::Int),
        Semicolon,
        If,
        OpenParen,
        Sizeof,
        OpenParen,
        Identifier,
        Ampersand,
        Identifier,
        CloseParen,
        BangEqual,
        IntConstant(IntKind::Int),
        CloseParen,
        OpenBrace,
        Return,
        IntConstant(IntKind::Int),
        Semicolon,
        CloseBrace,
        If,
        OpenParen,
        Sizeof,
        OpenParen,
        Identifier,
        Pipe,
        Identifier,
        CloseParen,
        BangEqual,
        IntConstant(IntKind::Int),
        CloseParen,
        OpenBrace,
        Return,
        IntConstant(IntKind::Int),
        Semicolon,
        CloseBrace,
        If,
        OpenParen,
        Sizeof,
        OpenParen,
        Identifier,
        Circumflex,
        Identifier,
        CloseParen,
        BangEqual,
        IntConstant(IntKind::Int),
        CloseParen,
        OpenBrace,
        Return,
        IntConstant(IntKind::Int),
        Semicolon,
        CloseBrace,
        If,
        OpenParen,
        Sizeof,
        OpenParen,
        Identifier,
        LessLess,
        Identifier,
        CloseParen,
        BangEqual,
        IntConstant(IntKind::Int),
        CloseParen,
        OpenBrace,
        Return,
        IntConstant(IntKind::Int),
        Semicolon,
        CloseBrace,
        If,
        OpenParen,
        Sizeof,
        OpenParen,
        Identifier,
        LessLess,
        Identifier,
        CloseParen,
        BangEqual,
        IntConstant(IntKind::Int),
        CloseParen,
        OpenBrace,
        Return,
        IntConstant(IntKind::Int),
        Semicolon,
        CloseBrace,
        If,
        OpenParen,
        Sizeof,
        OpenParen,
        Identifier,
        GreaterGreater,
        Identifier,
        CloseParen,
        BangEqual,
        IntConstant(IntKind::Int),
        CloseParen,
        OpenBrace,
        Return,
        IntConstant(IntKind::Int),
        Semicolon,
        CloseBrace,
        Return,
        IntConstant(IntKind::Int),
        Semicolon,
        CloseBrace,
    ];
    assert_eq!(tokenize(src), expected);
}

#[test]
fn test_valid_extra_credit_sizeof_compound() {
    let src = r#"
        int main(void) {
            long long_arr[2] = {1, 2};
            static int i = 3;
            static unsigned char uc = 4;
            double d = 5.0;
            long *ptr = long_arr;
            if (sizeof(long_arr[1] *= 10) != 8) {
                return 1;
            }
            if (sizeof(i /= 10ul) != 4) {
                return 2;
            }
            if (sizeof(uc %= 2) != 1) {
                return 3;
            }
            if (sizeof(d -= 11) != 8) {
                return 4;
            }
            if (sizeof(ptr += 1) != 8) {
                return 5;
            }
            if (long_arr[0] != 1) {
                return 6;
            }
            if (long_arr[1] != 2) {
                return 7;
            }
            if (i != 3) {
                return 8;
            }
            if (uc != 4) {
                return 9;
            }
            if (d != 5.0) {
                return 10;
            }
            if (ptr != long_arr) {
                return 11;
            }
            return 0;
        }
    "#;
    let expected = vec![
        Int,
        Identifier,
        OpenParen,
        Void,
        CloseParen,
        OpenBrace,
        Long,
        Identifier,
        OpenBracket,
        IntConstant(IntKind::Int),
        CloseBracket,
        Equal,
        OpenBrace,
        IntConstant(IntKind::Int),
        Comma,
        IntConstant(IntKind::Int),
        CloseBrace,
        Semicolon,
        Static,
        Int,
        Identifier,
        Equal,
        IntConstant(IntKind::Int),
        Semicolon,
        Static,
        Unsigned,
        Char,
        Identifier,
        Equal,
        IntConstant(IntKind::Int),
        Semicolon,
        Double,
        Identifier,
        Equal,
        DoubleConstant,
        Semicolon,
        Long,
        Star,
        Identifier,
        Equal,
        Identifier,
        Semicolon,
        If,
        OpenParen,
        Sizeof,
        OpenParen,
        Identifier,
        OpenBracket,
        IntConstant(IntKind::Int),
        CloseBracket,
        StarEqual,
        IntConstant(IntKind::Int),
        CloseParen,
        BangEqual,
        IntConstant(IntKind::Int),
        CloseParen,
        OpenBrace,
        Return,
        IntConstant(IntKind::Int),
        Semicolon,
        CloseBrace,
        If,
        OpenParen,
        Sizeof,
        OpenParen,
        Identifier,
        SlashEqual,
        IntConstant(IntKind::ULong),
        CloseParen,
        BangEqual,
        IntConstant(IntKind::Int),
        CloseParen,
        OpenBrace,
        Return,
        IntConstant(IntKind::Int),
        Semicolon,
        CloseBrace,
        If,
        OpenParen,
        Sizeof,
        OpenParen,
        Identifier,
        PercentEqual,
        IntConstant(IntKind::Int),
        CloseParen,
        BangEqual,
        IntConstant(IntKind::Int),
        CloseParen,
        OpenBrace,
        Return,
        IntConstant(IntKind::Int),
        Semicolon,
        CloseBrace,
        If,
        OpenParen,
        Sizeof,
        OpenParen,
        Identifier,
        MinusEqual,
        IntConstant(IntKind::Int),
        CloseParen,
        BangEqual,
        IntConstant(IntKind::Int),
        CloseParen,
        OpenBrace,
        Return,
        IntConstant(IntKind::Int),
        Semicolon,
        CloseBrace,
        If,
        OpenParen,
        Sizeof,
        OpenParen,
        Identifier,
        PlusEqual,
        IntConstant(IntKind::Int),
        CloseParen,
        BangEqual,
        IntConstant(IntKind::Int),
        CloseParen,
        OpenBrace,
        Return,
        IntConstant(IntKind::Int),
        Semicolon,
        CloseBrace,
        If,
        OpenParen,
        Identifier,
        OpenBracket,
        IntConstant(IntKind::Int),
        CloseBracket,
        BangEqual,
        IntConstant(IntKind::Int),
        CloseParen,
        OpenBrace,
        Return,
        IntConstant(IntKind::Int),
        Semicolon,
        CloseBrace,
        If,
        OpenParen,
        Identifier,
        OpenBracket,
        IntConstant(IntKind::Int),
        CloseBracket,
        BangEqual,
        IntConstant(IntKind::Int),
        CloseParen,
        OpenBrace,
        Return,
        IntConstant(IntKind::Int),
        Semicolon,
        CloseBrace,
        If,
        OpenParen,
        Identifier,
        BangEqual,
        IntConstant(IntKind::Int),
        CloseParen,
        OpenBrace,
        Return,
        IntConstant(IntKind::Int),
        Semicolon,
        CloseBrace,
        If,
        OpenParen,
        Identifier,
        BangEqual,
        IntConstant(IntKind::Int),
        CloseParen,
        OpenBrace,
        Return,
        IntConstant(IntKind::Int),
        Semicolon,
        CloseBrace,
        If,
        OpenParen,
        Identifier,
        BangEqual,
        DoubleConstant,
        CloseParen,
        OpenBrace,
        Return,
        IntConstant(IntKind::Int),
        Semicolon,
        CloseBrace,
        If,
        OpenParen,
        Identifier,
        BangEqual,
        Identifier,
        CloseParen,
        OpenBrace,
        Return,
        IntConstant(IntKind::Int),
        Semicolon,
        CloseBrace,
        Return,
        IntConstant(IntKind::Int),
        Semicolon,
        CloseBrace,
    ];
    assert_eq!(tokenize(src), expected);
}

#[test]
fn test_valid_extra_credit_sizeof_compound_bitwise() {
    let src = r#"
        int main(void) {
            static signed char sc = 10;
            unsigned int u = 10000u;
            long l = -99999;
            if (sizeof(sc &= l) != 1) {
                return 1;
            }
            if (sizeof(l |= u) != 8) {
                return 2;
            }
            if (sizeof(u ^= l) != 4) {
                return 3;
            }
            if (sizeof(l >>= sc) != 8) {
                return 4;
            }
            if (sizeof(sc <<= sc) != 1) {
                return 5;
            }
            if (sc != 10) {
                return 6;
            }
            if (u != 10000u) {
                return 7;
            }
            if (l != -99999) {
                return 8;
            }
            return 0;
        }
    "#;
    let expected = vec![
        Int,
        Identifier,
        OpenParen,
        Void,
        CloseParen,
        OpenBrace,
        Static,
        Signed,
        Char,
        Identifier,
        Equal,
        IntConstant(IntKind::Int),
        Semicolon,
        Unsigned,
        Int,
        Identifier,
        Equal,
        IntConstant(IntKind::Uint),
        Semicolon,
        Long,
        Identifier,
        Equal,
        Minus,
        IntConstant(IntKind::Int),
        Semicolon,
        If,
        OpenParen,
        Sizeof,
        OpenParen,
        Identifier,
        AmpersandEqual,
        Identifier,
        CloseParen,
        BangEqual,
        IntConstant(IntKind::Int),
        CloseParen,
        OpenBrace,
        Return,
        IntConstant(IntKind::Int),
        Semicolon,
        CloseBrace,
        If,
        OpenParen,
        Sizeof,
        OpenParen,
        Identifier,
        PipeEqual,
        Identifier,
        CloseParen,
        BangEqual,
        IntConstant(IntKind::Int),
        CloseParen,
        OpenBrace,
        Return,
        IntConstant(IntKind::Int),
        Semicolon,
        CloseBrace,
        If,
        OpenParen,
        Sizeof,
        OpenParen,
        Identifier,
        CircumflexEqual,
        Identifier,
        CloseParen,
        BangEqual,
        IntConstant(IntKind::Int),
        CloseParen,
        OpenBrace,
        Return,
        IntConstant(IntKind::Int),
        Semicolon,
        CloseBrace,
        If,
        OpenParen,
        Sizeof,
        OpenParen,
        Identifier,
        GreaterGreaterEqual,
        Identifier,
        CloseParen,
        BangEqual,
        IntConstant(IntKind::Int),
        CloseParen,
        OpenBrace,
        Return,
        IntConstant(IntKind::Int),
        Semicolon,
        CloseBrace,
        If,
        OpenParen,
        Sizeof,
        OpenParen,
        Identifier,
        LessLessEqual,
        Identifier,
        CloseParen,
        BangEqual,
        IntConstant(IntKind::Int),
        CloseParen,
        OpenBrace,
        Return,
        IntConstant(IntKind::Int),
        Semicolon,
        CloseBrace,
        If,
        OpenParen,
        Identifier,
        BangEqual,
        IntConstant(IntKind::Int),
        CloseParen,
        OpenBrace,
        Return,
        IntConstant(IntKind::Int),
        Semicolon,
        CloseBrace,
        If,
        OpenParen,
        Identifier,
        BangEqual,
        IntConstant(IntKind::Uint),
        CloseParen,
        OpenBrace,
        Return,
        IntConstant(IntKind::Int),
        Semicolon,
        CloseBrace,
        If,
        OpenParen,
        Identifier,
        BangEqual,
        Minus,
        IntConstant(IntKind::Int),
        CloseParen,
        OpenBrace,
        Return,
        IntConstant(IntKind::Int),
        Semicolon,
        CloseBrace,
        Return,
        IntConstant(IntKind::Int),
        Semicolon,
        CloseBrace,
    ];
    assert_eq!(tokenize(src), expected);
}

#[test]
fn test_valid_extra_credit_sizeof_incr() {
    let src = r#"
        int main(void) {
            int i = 0;
            long l = 0;
            static char arr[3] = {0, 0, 0};
            char *ptr = arr;
            if (sizeof (i++) != 4) {
                return 1;
            }
            if (sizeof (arr[0]--) != 1) {
                return 2;
            }
            if (sizeof (++l) != 8) {
                return 3;
            }
            if (sizeof (--arr[1]) != 1) {
                return 4;
            }
            if (sizeof (ptr--) != 8) {
                return 5;
            }
            if (i) {
                return 6;
            }
            if (l) {
                return 7;
            }
            if (arr[0] || arr[1] || arr[2]) {
                return 8;
            }
            if (ptr != arr) {
                return 9;
            }
            return 0;
        }
    "#;
    let expected = vec![
        Int,
        Identifier,
        OpenParen,
        Void,
        CloseParen,
        OpenBrace,
        Int,
        Identifier,
        Equal,
        IntConstant(IntKind::Int),
        Semicolon,
        Long,
        Identifier,
        Equal,
        IntConstant(IntKind::Int),
        Semicolon,
        Static,
        Char,
        Identifier,
        OpenBracket,
        IntConstant(IntKind::Int),
        CloseBracket,
        Equal,
        OpenBrace,
        IntConstant(IntKind::Int),
        Comma,
        IntConstant(IntKind::Int),
        Comma,
        IntConstant(IntKind::Int),
        CloseBrace,
        Semicolon,
        Char,
        Star,
        Identifier,
        Equal,
        Identifier,
        Semicolon,
        If,
        OpenParen,
        Sizeof,
        OpenParen,
        Identifier,
        PlusPlus,
        CloseParen,
        BangEqual,
        IntConstant(IntKind::Int),
        CloseParen,
        OpenBrace,
        Return,
        IntConstant(IntKind::Int),
        Semicolon,
        CloseBrace,
        If,
        OpenParen,
        Sizeof,
        OpenParen,
        Identifier,
        OpenBracket,
        IntConstant(IntKind::Int),
        CloseBracket,
        MinusMinus,
        CloseParen,
        BangEqual,
        IntConstant(IntKind::Int),
        CloseParen,
        OpenBrace,
        Return,
        IntConstant(IntKind::Int),
        Semicolon,
        CloseBrace,
        If,
        OpenParen,
        Sizeof,
        OpenParen,
        PlusPlus,
        Identifier,
        CloseParen,
        BangEqual,
        IntConstant(IntKind::Int),
        CloseParen,
        OpenBrace,
        Return,
        IntConstant(IntKind::Int),
        Semicolon,
        CloseBrace,
        If,
        OpenParen,
        Sizeof,
        OpenParen,
        MinusMinus,
        Identifier,
        OpenBracket,
        IntConstant(IntKind::Int),
        CloseBracket,
        CloseParen,
        BangEqual,
        IntConstant(IntKind::Int),
        CloseParen,
        OpenBrace,
        Return,
        IntConstant(IntKind::Int),
        Semicolon,
        CloseBrace,
        If,
        OpenParen,
        Sizeof,
        OpenParen,
        Identifier,
        MinusMinus,
        CloseParen,
        BangEqual,
        IntConstant(IntKind::Int),
        CloseParen,
        OpenBrace,
        Return,
        IntConstant(IntKind::Int),
        Semicolon,
        CloseBrace,
        If,
        OpenParen,
        Identifier,
        CloseParen,
        OpenBrace,
        Return,
        IntConstant(IntKind::Int),
        Semicolon,
        CloseBrace,
        If,
        OpenParen,
        Identifier,
        CloseParen,
        OpenBrace,
        Return,
        IntConstant(IntKind::Int),
        Semicolon,
        CloseBrace,
        If,
        OpenParen,
        Identifier,
        OpenBracket,
        IntConstant(IntKind::Int),
        CloseBracket,
        PipePipe,
        Identifier,
        OpenBracket,
        IntConstant(IntKind::Int),
        CloseBracket,
        PipePipe,
        Identifier,
        OpenBracket,
        IntConstant(IntKind::Int),
        CloseBracket,
        CloseParen,
        OpenBrace,
        Return,
        IntConstant(IntKind::Int),
        Semicolon,
        CloseBrace,
        If,
        OpenParen,
        Identifier,
        BangEqual,
        Identifier,
        CloseParen,
        OpenBrace,
        Return,
        IntConstant(IntKind::Int),
        Semicolon,
        CloseBrace,
        Return,
        IntConstant(IntKind::Int),
        Semicolon,
        CloseBrace,
    ];
    assert_eq!(tokenize(src), expected);
}

#[test]
fn test_valid_libraries_pass_alloced_memory() {
    let src = r#"
        void *calloc(unsigned long nmemb, unsigned long size);
        void *memset(void *s, int c, unsigned long n);
        void free(void *ptr);
        void *get_100_zeroed_bytes(void) {
            return calloc(100, 1);
        }
        void fill_100_bytes(void *pointer, int byte) {
            memset(pointer, byte, 100);
        }
        void free_bytes(void *ptr) {
            free(ptr);
        }
    "#;
    let expected = vec![
        Void,
        Star,
        Identifier,
        OpenParen,
        Unsigned,
        Long,
        Identifier,
        Comma,
        Unsigned,
        Long,
        Identifier,
        CloseParen,
        Semicolon,
        Void,
        Star,
        Identifier,
        OpenParen,
        Void,
        Star,
        Identifier,
        Comma,
        Int,
        Identifier,
        Comma,
        Unsigned,
        Long,
        Identifier,
        CloseParen,
        Semicolon,
        Void,
        Identifier,
        OpenParen,
        Void,
        Star,
        Identifier,
        CloseParen,
        Semicolon,
        Void,
        Star,
        Identifier,
        OpenParen,
        Void,
        CloseParen,
        OpenBrace,
        Return,
        Identifier,
        OpenParen,
        IntConstant(IntKind::Int),
        Comma,
        IntConstant(IntKind::Int),
        CloseParen,
        Semicolon,
        CloseBrace,
        Void,
        Identifier,
        OpenParen,
        Void,
        Star,
        Identifier,
        Comma,
        Int,
        Identifier,
        CloseParen,
        OpenBrace,
        Identifier,
        OpenParen,
        Identifier,
        Comma,
        Identifier,
        Comma,
        IntConstant(IntKind::Int),
        CloseParen,
        Semicolon,
        CloseBrace,
        Void,
        Identifier,
        OpenParen,
        Void,
        Star,
        Identifier,
        CloseParen,
        OpenBrace,
        Identifier,
        OpenParen,
        Identifier,
        CloseParen,
        Semicolon,
        CloseBrace,
    ];
    assert_eq!(tokenize(src), expected);
}

#[test]
fn test_valid_libraries_pass_alloced_memory_client() {
    let src = r#"
        void *get_100_zeroed_bytes(void);
        void fill_100_bytes(void *pointer, int byte);
        void free_bytes(void *ptr);
        int main(void) {
            void *mem = get_100_zeroed_bytes();
            for (int i = 0; i < 100; i = i + 1) {
                if (((char *) mem + i)[0]) {
                    return 1;
                }
            }
            fill_100_bytes(mem, 99);
            for (int i = 0; i < 100; i = i + 1) {
                if (((char *) mem + i)[0] != 99) {
                    return 2;
                }
            }
            free_bytes(mem);
            return 0;
        }
    "#;
    let expected = vec![
        Void,
        Star,
        Identifier,
        OpenParen,
        Void,
        CloseParen,
        Semicolon,
        Void,
        Identifier,
        OpenParen,
        Void,
        Star,
        Identifier,
        Comma,
        Int,
        Identifier,
        CloseParen,
        Semicolon,
        Void,
        Identifier,
        OpenParen,
        Void,
        Star,
        Identifier,
        CloseParen,
        Semicolon,
        Int,
        Identifier,
        OpenParen,
        Void,
        CloseParen,
        OpenBrace,
        Void,
        Star,
        Identifier,
        Equal,
        Identifier,
        OpenParen,
        CloseParen,
        Semicolon,
        For,
        OpenParen,
        Int,
        Identifier,
        Equal,
        IntConstant(IntKind::Int),
        Semicolon,
        Identifier,
        Less,
        IntConstant(IntKind::Int),
        Semicolon,
        Identifier,
        Equal,
        Identifier,
        Plus,
        IntConstant(IntKind::Int),
        CloseParen,
        OpenBrace,
        If,
        OpenParen,
        OpenParen,
        OpenParen,
        Char,
        Star,
        CloseParen,
        Identifier,
        Plus,
        Identifier,
        CloseParen,
        OpenBracket,
        IntConstant(IntKind::Int),
        CloseBracket,
        CloseParen,
        OpenBrace,
        Return,
        IntConstant(IntKind::Int),
        Semicolon,
        CloseBrace,
        CloseBrace,
        Identifier,
        OpenParen,
        Identifier,
        Comma,
        IntConstant(IntKind::Int),
        CloseParen,
        Semicolon,
        For,
        OpenParen,
        Int,
        Identifier,
        Equal,
        IntConstant(IntKind::Int),
        Semicolon,
        Identifier,
        Less,
        IntConstant(IntKind::Int),
        Semicolon,
        Identifier,
        Equal,
        Identifier,
        Plus,
        IntConstant(IntKind::Int),
        CloseParen,
        OpenBrace,
        If,
        OpenParen,
        OpenParen,
        OpenParen,
        Char,
        Star,
        CloseParen,
        Identifier,
        Plus,
        Identifier,
        CloseParen,
        OpenBracket,
        IntConstant(IntKind::Int),
        CloseBracket,
        BangEqual,
        IntConstant(IntKind::Int),
        CloseParen,
        OpenBrace,
        Return,
        IntConstant(IntKind::Int),
        Semicolon,
        CloseBrace,
        CloseBrace,
        Identifier,
        OpenParen,
        Identifier,
        CloseParen,
        Semicolon,
        Return,
        IntConstant(IntKind::Int),
        Semicolon,
        CloseBrace,
    ];
    assert_eq!(tokenize(src), expected);
}

#[test]
fn test_valid_libraries_sizeof_extern() {
    let src = r#"
        double large_array[1000][2000];
    "#;
    let expected = vec![
        Double,
        Identifier,
        OpenBracket,
        IntConstant(IntKind::Int),
        CloseBracket,
        OpenBracket,
        IntConstant(IntKind::Int),
        CloseBracket,
        Semicolon,
    ];
    assert_eq!(tokenize(src), expected);
}

#[test]
fn test_valid_libraries_sizeof_extern_client() {
    let src = r#"
        
        extern double large_array[1000][2000];
        int main(void) {
            return sizeof large_array == 16000000;
        }
    "#;
    let expected = vec![
        Extern,
        Double,
        Identifier,
        OpenBracket,
        IntConstant(IntKind::Int),
        CloseBracket,
        OpenBracket,
        IntConstant(IntKind::Int),
        CloseBracket,
        Semicolon,
        Int,
        Identifier,
        OpenParen,
        Void,
        CloseParen,
        OpenBrace,
        Return,
        Sizeof,
        Identifier,
        EqualEqual,
        IntConstant(IntKind::Int),
        Semicolon,
        CloseBrace,
    ];
    assert_eq!(tokenize(src), expected);
}

#[test]
fn test_valid_libraries_test_for_memory_leaks() {
    let src = r#"
        void exit(int status);
        long sum = 0;
        void lots_of_args(int a, int b, int c, int d, int e, int f, int g, int h, int i,
                          int j, int k, int l, int m, int n, int o) {
            if (a != 1) {
                exit(1);
            }
            if (b != 2) {
                exit(2);
            }
            if (c != 3) {
                exit(3);
            }
            if (d != 4) {
                exit(4);
            }
            if (e != 5) {
                exit(5);
            }
            if (f != 6) {
                exit(6);
            }
            if (g != 7) {
                exit(7);
            }
            if (h != 8) {
                exit(8);
            }
            if (i != 9) {
                exit(9);
            }
            if (j != 10) {
                exit(10);
            }
            if (k != 11) {
                exit(11);
            }
            if (l != 12) {
                exit(12);
            }
            if (m != 13) {
                exit(13);
            }
            if (n != 14) {
             exit(14);
            }
            sum = sum + o;
            return;
        }
    "#;
    let expected = vec![
        Void,
        Identifier,
        OpenParen,
        Int,
        Identifier,
        CloseParen,
        Semicolon,
        Long,
        Identifier,
        Equal,
        IntConstant(IntKind::Int),
        Semicolon,
        Void,
        Identifier,
        OpenParen,
        Int,
        Identifier,
        Comma,
        Int,
        Identifier,
        Comma,
        Int,
        Identifier,
        Comma,
        Int,
        Identifier,
        Comma,
        Int,
        Identifier,
        Comma,
        Int,
        Identifier,
        Comma,
        Int,
        Identifier,
        Comma,
        Int,
        Identifier,
        Comma,
        Int,
        Identifier,
        Comma,
        Int,
        Identifier,
        Comma,
        Int,
        Identifier,
        Comma,
        Int,
        Identifier,
        Comma,
        Int,
        Identifier,
        Comma,
        Int,
        Identifier,
        Comma,
        Int,
        Identifier,
        CloseParen,
        OpenBrace,
        If,
        OpenParen,
        Identifier,
        BangEqual,
        IntConstant(IntKind::Int),
        CloseParen,
        OpenBrace,
        Identifier,
        OpenParen,
        IntConstant(IntKind::Int),
        CloseParen,
        Semicolon,
        CloseBrace,
        If,
        OpenParen,
        Identifier,
        BangEqual,
        IntConstant(IntKind::Int),
        CloseParen,
        OpenBrace,
        Identifier,
        OpenParen,
        IntConstant(IntKind::Int),
        CloseParen,
        Semicolon,
        CloseBrace,
        If,
        OpenParen,
        Identifier,
        BangEqual,
        IntConstant(IntKind::Int),
        CloseParen,
        OpenBrace,
        Identifier,
        OpenParen,
        IntConstant(IntKind::Int),
        CloseParen,
        Semicolon,
        CloseBrace,
        If,
        OpenParen,
        Identifier,
        BangEqual,
        IntConstant(IntKind::Int),
        CloseParen,
        OpenBrace,
        Identifier,
        OpenParen,
        IntConstant(IntKind::Int),
        CloseParen,
        Semicolon,
        CloseBrace,
        If,
        OpenParen,
        Identifier,
        BangEqual,
        IntConstant(IntKind::Int),
        CloseParen,
        OpenBrace,
        Identifier,
        OpenParen,
        IntConstant(IntKind::Int),
        CloseParen,
        Semicolon,
        CloseBrace,
        If,
        OpenParen,
        Identifier,
        BangEqual,
        IntConstant(IntKind::Int),
        CloseParen,
        OpenBrace,
        Identifier,
        OpenParen,
        IntConstant(IntKind::Int),
        CloseParen,
        Semicolon,
        CloseBrace,
        If,
        OpenParen,
        Identifier,
        BangEqual,
        IntConstant(IntKind::Int),
        CloseParen,
        OpenBrace,
        Identifier,
        OpenParen,
        IntConstant(IntKind::Int),
        CloseParen,
        Semicolon,
        CloseBrace,
        If,
        OpenParen,
        Identifier,
        BangEqual,
        IntConstant(IntKind::Int),
        CloseParen,
        OpenBrace,
        Identifier,
        OpenParen,
        IntConstant(IntKind::Int),
        CloseParen,
        Semicolon,
        CloseBrace,
        If,
        OpenParen,
        Identifier,
        BangEqual,
        IntConstant(IntKind::Int),
        CloseParen,
        OpenBrace,
        Identifier,
        OpenParen,
        IntConstant(IntKind::Int),
        CloseParen,
        Semicolon,
        CloseBrace,
        If,
        OpenParen,
        Identifier,
        BangEqual,
        IntConstant(IntKind::Int),
        CloseParen,
        OpenBrace,
        Identifier,
        OpenParen,
        IntConstant(IntKind::Int),
        CloseParen,
        Semicolon,
        CloseBrace,
        If,
        OpenParen,
        Identifier,
        BangEqual,
        IntConstant(IntKind::Int),
        CloseParen,
        OpenBrace,
        Identifier,
        OpenParen,
        IntConstant(IntKind::Int),
        CloseParen,
        Semicolon,
        CloseBrace,
        If,
        OpenParen,
        Identifier,
        BangEqual,
        IntConstant(IntKind::Int),
        CloseParen,
        OpenBrace,
        Identifier,
        OpenParen,
        IntConstant(IntKind::Int),
        CloseParen,
        Semicolon,
        CloseBrace,
        If,
        OpenParen,
        Identifier,
        BangEqual,
        IntConstant(IntKind::Int),
        CloseParen,
        OpenBrace,
        Identifier,
        OpenParen,
        IntConstant(IntKind::Int),
        CloseParen,
        Semicolon,
        CloseBrace,
        If,
        OpenParen,
        Identifier,
        BangEqual,
        IntConstant(IntKind::Int),
        CloseParen,
        OpenBrace,
        Identifier,
        OpenParen,
        IntConstant(IntKind::Int),
        CloseParen,
        Semicolon,
        CloseBrace,
        Identifier,
        Equal,
        Identifier,
        Plus,
        Identifier,
        Semicolon,
        Return,
        Semicolon,
        CloseBrace,
    ];
    assert_eq!(tokenize(src), expected);
}

#[test]
fn test_valid_libraries_test_for_memory_leaks_client() {
    let src = r#"
        extern long sum;
        void lots_of_args(int a, int b, int c, int d, int e, int f, int g, int h, int i, int j, int k, int l, int m, int n, int o);
        int main(void) {
            for (int i = 0; i < 10000000; i = i + 1) {
                lots_of_args(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, i);
            }
            if (sum != 49999995000000) {
                return 15;
            }
            return 0;
        }
    "#;
    let expected = vec![
        Extern,
        Long,
        Identifier,
        Semicolon,
        Void,
        Identifier,
        OpenParen,
        Int,
        Identifier,
        Comma,
        Int,
        Identifier,
        Comma,
        Int,
        Identifier,
        Comma,
        Int,
        Identifier,
        Comma,
        Int,
        Identifier,
        Comma,
        Int,
        Identifier,
        Comma,
        Int,
        Identifier,
        Comma,
        Int,
        Identifier,
        Comma,
        Int,
        Identifier,
        Comma,
        Int,
        Identifier,
        Comma,
        Int,
        Identifier,
        Comma,
        Int,
        Identifier,
        Comma,
        Int,
        Identifier,
        Comma,
        Int,
        Identifier,
        Comma,
        Int,
        Identifier,
        CloseParen,
        Semicolon,
        Int,
        Identifier,
        OpenParen,
        Void,
        CloseParen,
        OpenBrace,
        For,
        OpenParen,
        Int,
        Identifier,
        Equal,
        IntConstant(IntKind::Int),
        Semicolon,
        Identifier,
        Less,
        IntConstant(IntKind::Int),
        Semicolon,
        Identifier,
        Equal,
        Identifier,
        Plus,
        IntConstant(IntKind::Int),
        CloseParen,
        OpenBrace,
        Identifier,
        OpenParen,
        IntConstant(IntKind::Int),
        Comma,
        IntConstant(IntKind::Int),
        Comma,
        IntConstant(IntKind::Int),
        Comma,
        IntConstant(IntKind::Int),
        Comma,
        IntConstant(IntKind::Int),
        Comma,
        IntConstant(IntKind::Int),
        Comma,
        IntConstant(IntKind::Int),
        Comma,
        IntConstant(IntKind::Int),
        Comma,
        IntConstant(IntKind::Int),
        Comma,
        IntConstant(IntKind::Int),
        Comma,
        IntConstant(IntKind::Int),
        Comma,
        IntConstant(IntKind::Int),
        Comma,
        IntConstant(IntKind::Int),
        Comma,
        IntConstant(IntKind::Int),
        Comma,
        Identifier,
        CloseParen,
        Semicolon,
        CloseBrace,
        If,
        OpenParen,
        Identifier,
        BangEqual,
        IntConstant(IntKind::Int),
        CloseParen,
        OpenBrace,
        Return,
        IntConstant(IntKind::Int),
        Semicolon,
        CloseBrace,
        Return,
        IntConstant(IntKind::Int),
        Semicolon,
        CloseBrace,
    ];
    assert_eq!(tokenize(src), expected);
}

#[test]
fn test_valid_sizeof_simple() {
    let src = r#"
        int main(void) {
            if (sizeof (int) != 4) {
                return 1;
            }
            if (sizeof 3.0 != 8) {
                return 2;
            }
            return 0;
        }
    "#;
    let expected = vec![
        Int,
        Identifier,
        OpenParen,
        Void,
        CloseParen,
        OpenBrace,
        If,
        OpenParen,
        Sizeof,
        OpenParen,
        Int,
        CloseParen,
        BangEqual,
        IntConstant(IntKind::Int),
        CloseParen,
        OpenBrace,
        Return,
        IntConstant(IntKind::Int),
        Semicolon,
        CloseBrace,
        If,
        OpenParen,
        Sizeof,
        DoubleConstant,
        BangEqual,
        IntConstant(IntKind::Int),
        CloseParen,
        OpenBrace,
        Return,
        IntConstant(IntKind::Int),
        Semicolon,
        CloseBrace,
        Return,
        IntConstant(IntKind::Int),
        Semicolon,
        CloseBrace,
    ];
    assert_eq!(tokenize(src), expected);
}

#[test]
fn test_valid_sizeof_sizeof_array() {
    let src = r#"
        unsigned long sizeof_adjusted_param(int arr[3]) {
            return sizeof arr;
        }
        int main(void) {
            int arr[3];
            if (sizeof arr != 12) {
                return 1;
            }
            static long nested_arr[4][5];
            if (sizeof nested_arr[2] != 40) {
                return 2;
            }
            if (sizeof "Hello, World!" != 14) {
                return 3;
            }
            if (sizeof_adjusted_param(arr) != 8) {
                return 4;
            }
            return 0;
        }
    "#;
    let expected = vec![
        Unsigned,
        Long,
        Identifier,
        OpenParen,
        Int,
        Identifier,
        OpenBracket,
        IntConstant(IntKind::Int),
        CloseBracket,
        CloseParen,
        OpenBrace,
        Return,
        Sizeof,
        Identifier,
        Semicolon,
        CloseBrace,
        Int,
        Identifier,
        OpenParen,
        Void,
        CloseParen,
        OpenBrace,
        Int,
        Identifier,
        OpenBracket,
        IntConstant(IntKind::Int),
        CloseBracket,
        Semicolon,
        If,
        OpenParen,
        Sizeof,
        Identifier,
        BangEqual,
        IntConstant(IntKind::Int),
        CloseParen,
        OpenBrace,
        Return,
        IntConstant(IntKind::Int),
        Semicolon,
        CloseBrace,
        Static,
        Long,
        Identifier,
        OpenBracket,
        IntConstant(IntKind::Int),
        CloseBracket,
        OpenBracket,
        IntConstant(IntKind::Int),
        CloseBracket,
        Semicolon,
        If,
        OpenParen,
        Sizeof,
        Identifier,
        OpenBracket,
        IntConstant(IntKind::Int),
        CloseBracket,
        BangEqual,
        IntConstant(IntKind::Int),
        CloseParen,
        OpenBrace,
        Return,
        IntConstant(IntKind::Int),
        Semicolon,
        CloseBrace,
        If,
        OpenParen,
        Sizeof,
        StringLiteral,
        BangEqual,
        IntConstant(IntKind::Int),
        CloseParen,
        OpenBrace,
        Return,
        IntConstant(IntKind::Int),
        Semicolon,
        CloseBrace,
        If,
        OpenParen,
        Identifier,
        OpenParen,
        Identifier,
        CloseParen,
        BangEqual,
        IntConstant(IntKind::Int),
        CloseParen,
        OpenBrace,
        Return,
        IntConstant(IntKind::Int),
        Semicolon,
        CloseBrace,
        Return,
        IntConstant(IntKind::Int),
        Semicolon,
        CloseBrace,
    ];
    assert_eq!(tokenize(src), expected);
}

#[test]
fn test_valid_sizeof_sizeof_basic_types() {
    let src = r#"
        int main(void) {
            if (sizeof(char) != 1) {
                return 1;
            }
            if (sizeof(signed char) != 1) {
                return 2;
            }
            if (sizeof(unsigned char) != 1) {
                return 3;
            }
            if (sizeof(int) != 4) {
                return 4;
            }
            if (sizeof(unsigned int) != 4) {
                return 5;
            }
            if (sizeof(long) != 8) {
                return 6;
            }
            if (sizeof(unsigned long) != 8) {
                return 7;
            }
            if (sizeof(double) != 8) {
                return 8;
            }
            return 0;
        }
    "#;
    let expected = vec![
        Int,
        Identifier,
        OpenParen,
        Void,
        CloseParen,
        OpenBrace,
        If,
        OpenParen,
        Sizeof,
        OpenParen,
        Char,
        CloseParen,
        BangEqual,
        IntConstant(IntKind::Int),
        CloseParen,
        OpenBrace,
        Return,
        IntConstant(IntKind::Int),
        Semicolon,
        CloseBrace,
        If,
        OpenParen,
        Sizeof,
        OpenParen,
        Signed,
        Char,
        CloseParen,
        BangEqual,
        IntConstant(IntKind::Int),
        CloseParen,
        OpenBrace,
        Return,
        IntConstant(IntKind::Int),
        Semicolon,
        CloseBrace,
        If,
        OpenParen,
        Sizeof,
        OpenParen,
        Unsigned,
        Char,
        CloseParen,
        BangEqual,
        IntConstant(IntKind::Int),
        CloseParen,
        OpenBrace,
        Return,
        IntConstant(IntKind::Int),
        Semicolon,
        CloseBrace,
        If,
        OpenParen,
        Sizeof,
        OpenParen,
        Int,
        CloseParen,
        BangEqual,
        IntConstant(IntKind::Int),
        CloseParen,
        OpenBrace,
        Return,
        IntConstant(IntKind::Int),
        Semicolon,
        CloseBrace,
        If,
        OpenParen,
        Sizeof,
        OpenParen,
        Unsigned,
        Int,
        CloseParen,
        BangEqual,
        IntConstant(IntKind::Int),
        CloseParen,
        OpenBrace,
        Return,
        IntConstant(IntKind::Int),
        Semicolon,
        CloseBrace,
        If,
        OpenParen,
        Sizeof,
        OpenParen,
        Long,
        CloseParen,
        BangEqual,
        IntConstant(IntKind::Int),
        CloseParen,
        OpenBrace,
        Return,
        IntConstant(IntKind::Int),
        Semicolon,
        CloseBrace,
        If,
        OpenParen,
        Sizeof,
        OpenParen,
        Unsigned,
        Long,
        CloseParen,
        BangEqual,
        IntConstant(IntKind::Int),
        CloseParen,
        OpenBrace,
        Return,
        IntConstant(IntKind::Int),
        Semicolon,
        CloseBrace,
        If,
        OpenParen,
        Sizeof,
        OpenParen,
        Double,
        CloseParen,
        BangEqual,
        IntConstant(IntKind::Int),
        CloseParen,
        OpenBrace,
        Return,
        IntConstant(IntKind::Int),
        Semicolon,
        CloseBrace,
        Return,
        IntConstant(IntKind::Int),
        Semicolon,
        CloseBrace,
    ];
    assert_eq!(tokenize(src), expected);
}

#[test]
fn test_valid_sizeof_sizeof_consts() {
    let src = r#"
        int main(void) {
            if (sizeof 'a' != 4) {
                return 1;
            }
            if (sizeof 2147483647 != 4) {
                return 2;
            }
            if (sizeof 4294967295U != 4) {
                return 3;
            }
            if (sizeof 2l != 8) {
                return 4;
            }
            if (sizeof 0ul != 8) {
                return 5;
            }
            if (sizeof 1.0 != 8) {
                return 6;
            }
            return 0;
        }
    "#;
    let expected = vec![
        Int,
        Identifier,
        OpenParen,
        Void,
        CloseParen,
        OpenBrace,
        If,
        OpenParen,
        Sizeof,
        CharLiteral,
        BangEqual,
        IntConstant(IntKind::Int),
        CloseParen,
        OpenBrace,
        Return,
        IntConstant(IntKind::Int),
        Semicolon,
        CloseBrace,
        If,
        OpenParen,
        Sizeof,
        IntConstant(IntKind::Int),
        BangEqual,
        IntConstant(IntKind::Int),
        CloseParen,
        OpenBrace,
        Return,
        IntConstant(IntKind::Int),
        Semicolon,
        CloseBrace,
        If,
        OpenParen,
        Sizeof,
        IntConstant(IntKind::Uint),
        BangEqual,
        IntConstant(IntKind::Int),
        CloseParen,
        OpenBrace,
        Return,
        IntConstant(IntKind::Int),
        Semicolon,
        CloseBrace,
        If,
        OpenParen,
        Sizeof,
        IntConstant(IntKind::Long),
        BangEqual,
        IntConstant(IntKind::Int),
        CloseParen,
        OpenBrace,
        Return,
        IntConstant(IntKind::Int),
        Semicolon,
        CloseBrace,
        If,
        OpenParen,
        Sizeof,
        IntConstant(IntKind::ULong),
        BangEqual,
        IntConstant(IntKind::Int),
        CloseParen,
        OpenBrace,
        Return,
        IntConstant(IntKind::Int),
        Semicolon,
        CloseBrace,
        If,
        OpenParen,
        Sizeof,
        DoubleConstant,
        BangEqual,
        IntConstant(IntKind::Int),
        CloseParen,
        OpenBrace,
        Return,
        IntConstant(IntKind::Int),
        Semicolon,
        CloseBrace,
        Return,
        IntConstant(IntKind::Int),
        Semicolon,
        CloseBrace,
    ];
    assert_eq!(tokenize(src), expected);
}

#[test]
fn test_valid_sizeof_sizeof_derived_types() {
    let src = r#"
        void *malloc(unsigned long size);
        int main(void) {
            if (sizeof(int[2]) != 8) {
                return 1;
            }
            if (sizeof(char[3][6][17][9]) != 2754) {
                return 2;
            }
            if (sizeof(int[4294967297L][100000000]) != 1717986918800000000l) {
                return 3;
            }
            if (sizeof(int *) != 8) {
                return 4;
            }
            if (sizeof(int(*)[2][4][6]) !=
                8) {
                return 5;
            }
            if (sizeof(char *) != 8) {
                return 6;
            }
            if (sizeof(double(*([3][4]))[2]) != 96) {
                return 7;
            }
            return 0;
        }
    "#;
    let expected = vec![
        Void,
        Star,
        Identifier,
        OpenParen,
        Unsigned,
        Long,
        Identifier,
        CloseParen,
        Semicolon,
        Int,
        Identifier,
        OpenParen,
        Void,
        CloseParen,
        OpenBrace,
        If,
        OpenParen,
        Sizeof,
        OpenParen,
        Int,
        OpenBracket,
        IntConstant(IntKind::Int),
        CloseBracket,
        CloseParen,
        BangEqual,
        IntConstant(IntKind::Int),
        CloseParen,
        OpenBrace,
        Return,
        IntConstant(IntKind::Int),
        Semicolon,
        CloseBrace,
        If,
        OpenParen,
        Sizeof,
        OpenParen,
        Char,
        OpenBracket,
        IntConstant(IntKind::Int),
        CloseBracket,
        OpenBracket,
        IntConstant(IntKind::Int),
        CloseBracket,
        OpenBracket,
        IntConstant(IntKind::Int),
        CloseBracket,
        OpenBracket,
        IntConstant(IntKind::Int),
        CloseBracket,
        CloseParen,
        BangEqual,
        IntConstant(IntKind::Int),
        CloseParen,
        OpenBrace,
        Return,
        IntConstant(IntKind::Int),
        Semicolon,
        CloseBrace,
        If,
        OpenParen,
        Sizeof,
        OpenParen,
        Int,
        OpenBracket,
        IntConstant(IntKind::Long),
        CloseBracket,
        OpenBracket,
        IntConstant(IntKind::Int),
        CloseBracket,
        CloseParen,
        BangEqual,
        IntConstant(IntKind::Long),
        CloseParen,
        OpenBrace,
        Return,
        IntConstant(IntKind::Int),
        Semicolon,
        CloseBrace,
        If,
        OpenParen,
        Sizeof,
        OpenParen,
        Int,
        Star,
        CloseParen,
        BangEqual,
        IntConstant(IntKind::Int),
        CloseParen,
        OpenBrace,
        Return,
        IntConstant(IntKind::Int),
        Semicolon,
        CloseBrace,
        If,
        OpenParen,
        Sizeof,
        OpenParen,
        Int,
        OpenParen,
        Star,
        CloseParen,
        OpenBracket,
        IntConstant(IntKind::Int),
        CloseBracket,
        OpenBracket,
        IntConstant(IntKind::Int),
        CloseBracket,
        OpenBracket,
        IntConstant(IntKind::Int),
        CloseBracket,
        CloseParen,
        BangEqual,
        IntConstant(IntKind::Int),
        CloseParen,
        OpenBrace,
        Return,
        IntConstant(IntKind::Int),
        Semicolon,
        CloseBrace,
        If,
        OpenParen,
        Sizeof,
        OpenParen,
        Char,
        Star,
        CloseParen,
        BangEqual,
        IntConstant(IntKind::Int),
        CloseParen,
        OpenBrace,
        Return,
        IntConstant(IntKind::Int),
        Semicolon,
        CloseBrace,
        If,
        OpenParen,
        Sizeof,
        OpenParen,
        Double,
        OpenParen,
        Star,
        OpenParen,
        OpenBracket,
        IntConstant(IntKind::Int),
        CloseBracket,
        OpenBracket,
        IntConstant(IntKind::Int),
        CloseBracket,
        CloseParen,
        CloseParen,
        OpenBracket,
        IntConstant(IntKind::Int),
        CloseBracket,
        CloseParen,
        BangEqual,
        IntConstant(IntKind::Int),
        CloseParen,
        OpenBrace,
        Return,
        IntConstant(IntKind::Int),
        Semicolon,
        CloseBrace,
        Return,
        IntConstant(IntKind::Int),
        Semicolon,
        CloseBrace,
    ];
    assert_eq!(tokenize(src), expected);
}

#[test]
fn test_valid_sizeof_sizeof_expressions() {
    let src = r#"
        void *malloc(unsigned long size);
        void free(void *ptr);
        int main(void) {
            double d;
            if (sizeof d != 8) {
                return 2;
            }
            unsigned char c;
            if (sizeof c != 1) {
                return 3;
            }
            void *buffer = malloc(100);
            if (sizeof(buffer) != 8) {
                return 4;
            }
            free(buffer);
            if (sizeof ((int)d) != 4) {
                return 5;
            }
            if (sizeof (d ? c : 10l) != 8) {
                return 6;
            }
            if (sizeof (c = 10.0) != 1) {
                return 7;
            }
            return 0;
        }
    "#;
    let expected = vec![
        Void,
        Star,
        Identifier,
        OpenParen,
        Unsigned,
        Long,
        Identifier,
        CloseParen,
        Semicolon,
        Void,
        Identifier,
        OpenParen,
        Void,
        Star,
        Identifier,
        CloseParen,
        Semicolon,
        Int,
        Identifier,
        OpenParen,
        Void,
        CloseParen,
        OpenBrace,
        Double,
        Identifier,
        Semicolon,
        If,
        OpenParen,
        Sizeof,
        Identifier,
        BangEqual,
        IntConstant(IntKind::Int),
        CloseParen,
        OpenBrace,
        Return,
        IntConstant(IntKind::Int),
        Semicolon,
        CloseBrace,
        Unsigned,
        Char,
        Identifier,
        Semicolon,
        If,
        OpenParen,
        Sizeof,
        Identifier,
        BangEqual,
        IntConstant(IntKind::Int),
        CloseParen,
        OpenBrace,
        Return,
        IntConstant(IntKind::Int),
        Semicolon,
        CloseBrace,
        Void,
        Star,
        Identifier,
        Equal,
        Identifier,
        OpenParen,
        IntConstant(IntKind::Int),
        CloseParen,
        Semicolon,
        If,
        OpenParen,
        Sizeof,
        OpenParen,
        Identifier,
        CloseParen,
        BangEqual,
        IntConstant(IntKind::Int),
        CloseParen,
        OpenBrace,
        Return,
        IntConstant(IntKind::Int),
        Semicolon,
        CloseBrace,
        Identifier,
        OpenParen,
        Identifier,
        CloseParen,
        Semicolon,
        If,
        OpenParen,
        Sizeof,
        OpenParen,
        OpenParen,
        Int,
        CloseParen,
        Identifier,
        CloseParen,
        BangEqual,
        IntConstant(IntKind::Int),
        CloseParen,
        OpenBrace,
        Return,
        IntConstant(IntKind::Int),
        Semicolon,
        CloseBrace,
        If,
        OpenParen,
        Sizeof,
        OpenParen,
        Identifier,
        Question,
        Identifier,
        Colon,
        IntConstant(IntKind::Long),
        CloseParen,
        BangEqual,
        IntConstant(IntKind::Int),
        CloseParen,
        OpenBrace,
        Return,
        IntConstant(IntKind::Int),
        Semicolon,
        CloseBrace,
        If,
        OpenParen,
        Sizeof,
        OpenParen,
        Identifier,
        Equal,
        DoubleConstant,
        CloseParen,
        BangEqual,
        IntConstant(IntKind::Int),
        CloseParen,
        OpenBrace,
        Return,
        IntConstant(IntKind::Int),
        Semicolon,
        CloseBrace,
        Return,
        IntConstant(IntKind::Int),
        Semicolon,
        CloseBrace,
    ];
    assert_eq!(tokenize(src), expected);
}

#[test]
fn test_valid_sizeof_sizeof_not_evaluated() {
    let src = r#"
        void exit(int status);
        int foo(void) { exit(10); }
        int main(void) {
          return sizeof(foo());
        }
    "#;
    let expected = vec![
        Void,
        Identifier,
        OpenParen,
        Int,
        Identifier,
        CloseParen,
        Semicolon,
        Int,
        Identifier,
        OpenParen,
        Void,
        CloseParen,
        OpenBrace,
        Identifier,
        OpenParen,
        IntConstant(IntKind::Int),
        CloseParen,
        Semicolon,
        CloseBrace,
        Int,
        Identifier,
        OpenParen,
        Void,
        CloseParen,
        OpenBrace,
        Return,
        Sizeof,
        OpenParen,
        Identifier,
        OpenParen,
        CloseParen,
        CloseParen,
        Semicolon,
        CloseBrace,
    ];
    assert_eq!(tokenize(src), expected);
}

#[test]
fn test_valid_sizeof_sizeof_result_is_ulong() {
    let src = r#"
        int main(void) {
            if (sizeof sizeof (char) != 8) {
                return 1;
            }
            if (sizeof 4 - sizeof 4 - 1 < 0) {
                return 2;
            }
            return 0;
        }
    "#;
    let expected = vec![
        Int,
        Identifier,
        OpenParen,
        Void,
        CloseParen,
        OpenBrace,
        If,
        OpenParen,
        Sizeof,
        Sizeof,
        OpenParen,
        Char,
        CloseParen,
        BangEqual,
        IntConstant(IntKind::Int),
        CloseParen,
        OpenBrace,
        Return,
        IntConstant(IntKind::Int),
        Semicolon,
        CloseBrace,
        If,
        OpenParen,
        Sizeof,
        IntConstant(IntKind::Int),
        Minus,
        Sizeof,
        IntConstant(IntKind::Int),
        Minus,
        IntConstant(IntKind::Int),
        Less,
        IntConstant(IntKind::Int),
        CloseParen,
        OpenBrace,
        Return,
        IntConstant(IntKind::Int),
        Semicolon,
        CloseBrace,
        Return,
        IntConstant(IntKind::Int),
        Semicolon,
        CloseBrace,
    ];
    assert_eq!(tokenize(src), expected);
}

#[test]
fn test_valid_void_cast_to_void() {
    let src = r#"
        int x;
        int set_x(int i) {
            x = i;
            return 0;
        }
        void do_nothing(void) {
            ;
        }
        int main(void) {
            (void) x;
            (void) set_x(12);
            (void) do_nothing();
            return x;
        }
    "#;
    let expected = vec![
        Int,
        Identifier,
        Semicolon,
        Int,
        Identifier,
        OpenParen,
        Int,
        Identifier,
        CloseParen,
        OpenBrace,
        Identifier,
        Equal,
        Identifier,
        Semicolon,
        Return,
        IntConstant(IntKind::Int),
        Semicolon,
        CloseBrace,
        Void,
        Identifier,
        OpenParen,
        Void,
        CloseParen,
        OpenBrace,
        Semicolon,
        CloseBrace,
        Int,
        Identifier,
        OpenParen,
        Void,
        CloseParen,
        OpenBrace,
        OpenParen,
        Void,
        CloseParen,
        Identifier,
        Semicolon,
        OpenParen,
        Void,
        CloseParen,
        Identifier,
        OpenParen,
        IntConstant(IntKind::Int),
        CloseParen,
        Semicolon,
        OpenParen,
        Void,
        CloseParen,
        Identifier,
        OpenParen,
        CloseParen,
        Semicolon,
        Return,
        Identifier,
        Semicolon,
        CloseBrace,
    ];
    assert_eq!(tokenize(src), expected);
}

#[test]
fn test_valid_void_ternary() {
    let src = r#"
        int i = 4;
        int j = 5;
        int flag_1 = 1;
        int flag_0 = 0;
        void incr_i(void) {
            i = i + 1;
        }
        void incr_j(void) {
            j = j + 1;
        }
        int main(void) {
            flag_1 ? incr_i() : incr_j();
            flag_0 ? incr_i() : incr_j();
            if (i != 5) {
                return 1;
            }
            if (j != 6) {
                return 2;
            }
            flag_0 ? incr_j() : flag_1 ? incr_i() : incr_j();
            if (i != 6) {
                return 3;
            }
            if (j != 6) {
                return 4;
            }
            return 0;
        }
    "#;
    let expected = vec![
        Int,
        Identifier,
        Equal,
        IntConstant(IntKind::Int),
        Semicolon,
        Int,
        Identifier,
        Equal,
        IntConstant(IntKind::Int),
        Semicolon,
        Int,
        Identifier,
        Equal,
        IntConstant(IntKind::Int),
        Semicolon,
        Int,
        Identifier,
        Equal,
        IntConstant(IntKind::Int),
        Semicolon,
        Void,
        Identifier,
        OpenParen,
        Void,
        CloseParen,
        OpenBrace,
        Identifier,
        Equal,
        Identifier,
        Plus,
        IntConstant(IntKind::Int),
        Semicolon,
        CloseBrace,
        Void,
        Identifier,
        OpenParen,
        Void,
        CloseParen,
        OpenBrace,
        Identifier,
        Equal,
        Identifier,
        Plus,
        IntConstant(IntKind::Int),
        Semicolon,
        CloseBrace,
        Int,
        Identifier,
        OpenParen,
        Void,
        CloseParen,
        OpenBrace,
        Identifier,
        Question,
        Identifier,
        OpenParen,
        CloseParen,
        Colon,
        Identifier,
        OpenParen,
        CloseParen,
        Semicolon,
        Identifier,
        Question,
        Identifier,
        OpenParen,
        CloseParen,
        Colon,
        Identifier,
        OpenParen,
        CloseParen,
        Semicolon,
        If,
        OpenParen,
        Identifier,
        BangEqual,
        IntConstant(IntKind::Int),
        CloseParen,
        OpenBrace,
        Return,
        IntConstant(IntKind::Int),
        Semicolon,
        CloseBrace,
        If,
        OpenParen,
        Identifier,
        BangEqual,
        IntConstant(IntKind::Int),
        CloseParen,
        OpenBrace,
        Return,
        IntConstant(IntKind::Int),
        Semicolon,
        CloseBrace,
        Identifier,
        Question,
        Identifier,
        OpenParen,
        CloseParen,
        Colon,
        Identifier,
        Question,
        Identifier,
        OpenParen,
        CloseParen,
        Colon,
        Identifier,
        OpenParen,
        CloseParen,
        Semicolon,
        If,
        OpenParen,
        Identifier,
        BangEqual,
        IntConstant(IntKind::Int),
        CloseParen,
        OpenBrace,
        Return,
        IntConstant(IntKind::Int),
        Semicolon,
        CloseBrace,
        If,
        OpenParen,
        Identifier,
        BangEqual,
        IntConstant(IntKind::Int),
        CloseParen,
        OpenBrace,
        Return,
        IntConstant(IntKind::Int),
        Semicolon,
        CloseBrace,
        Return,
        IntConstant(IntKind::Int),
        Semicolon,
        CloseBrace,
    ];
    assert_eq!(tokenize(src), expected);
}

#[test]
fn test_valid_void_void_for_loop() {
    let src = r#"
        int putchar(int c);
        int letter;
        void initialize_letter(void) {
            letter = 'Z';
        }
        void decrement_letter(void) {
            letter = letter - 1;
        }
        int main(void) {
            for (initialize_letter(); letter >= 'A';
                 letter = letter - 1) {
                putchar(letter);
            }
            for (letter = 'A'; letter <= 90; (void)(letter = letter + 1)) {
                putchar(letter);
            }
            for (initialize_letter(); letter >= 65; decrement_letter()) {
                putchar(letter);
            }
            return 0;
        }
    "#;
    let expected = vec![
        Int,
        Identifier,
        OpenParen,
        Int,
        Identifier,
        CloseParen,
        Semicolon,
        Int,
        Identifier,
        Semicolon,
        Void,
        Identifier,
        OpenParen,
        Void,
        CloseParen,
        OpenBrace,
        Identifier,
        Equal,
        CharLiteral,
        Semicolon,
        CloseBrace,
        Void,
        Identifier,
        OpenParen,
        Void,
        CloseParen,
        OpenBrace,
        Identifier,
        Equal,
        Identifier,
        Minus,
        IntConstant(IntKind::Int),
        Semicolon,
        CloseBrace,
        Int,
        Identifier,
        OpenParen,
        Void,
        CloseParen,
        OpenBrace,
        For,
        OpenParen,
        Identifier,
        OpenParen,
        CloseParen,
        Semicolon,
        Identifier,
        GreaterEqual,
        CharLiteral,
        Semicolon,
        Identifier,
        Equal,
        Identifier,
        Minus,
        IntConstant(IntKind::Int),
        CloseParen,
        OpenBrace,
        Identifier,
        OpenParen,
        Identifier,
        CloseParen,
        Semicolon,
        CloseBrace,
        For,
        OpenParen,
        Identifier,
        Equal,
        CharLiteral,
        Semicolon,
        Identifier,
        LessEqual,
        IntConstant(IntKind::Int),
        Semicolon,
        OpenParen,
        Void,
        CloseParen,
        OpenParen,
        Identifier,
        Equal,
        Identifier,
        Plus,
        IntConstant(IntKind::Int),
        CloseParen,
        CloseParen,
        OpenBrace,
        Identifier,
        OpenParen,
        Identifier,
        CloseParen,
        Semicolon,
        CloseBrace,
        For,
        OpenParen,
        Identifier,
        OpenParen,
        CloseParen,
        Semicolon,
        Identifier,
        GreaterEqual,
        IntConstant(IntKind::Int),
        Semicolon,
        Identifier,
        OpenParen,
        CloseParen,
        CloseParen,
        OpenBrace,
        Identifier,
        OpenParen,
        Identifier,
        CloseParen,
        Semicolon,
        CloseBrace,
        Return,
        IntConstant(IntKind::Int),
        Semicolon,
        CloseBrace,
    ];
    assert_eq!(tokenize(src), expected);
}

#[test]
fn test_valid_void_void_function() {
    let src = r#"
        
        int foo = 0;
        void set_foo_to_positive_num(int a) {
            if (a < 0) {
                return;
            }
            foo = a;
            return;
        }
        void do_nothing(void) {
        }
        int main(void) {
            set_foo_to_positive_num(-2);
            if (foo) {
                return 1;
            }
            set_foo_to_positive_num(12);
            if (foo != 12) {
                return 2;
            }
            do_nothing();
            return 0;
        }
    "#;
    let expected = vec![
        Int,
        Identifier,
        Equal,
        IntConstant(IntKind::Int),
        Semicolon,
        Void,
        Identifier,
        OpenParen,
        Int,
        Identifier,
        CloseParen,
        OpenBrace,
        If,
        OpenParen,
        Identifier,
        Less,
        IntConstant(IntKind::Int),
        CloseParen,
        OpenBrace,
        Return,
        Semicolon,
        CloseBrace,
        Identifier,
        Equal,
        Identifier,
        Semicolon,
        Return,
        Semicolon,
        CloseBrace,
        Void,
        Identifier,
        OpenParen,
        Void,
        CloseParen,
        OpenBrace,
        CloseBrace,
        Int,
        Identifier,
        OpenParen,
        Void,
        CloseParen,
        OpenBrace,
        Identifier,
        OpenParen,
        Minus,
        IntConstant(IntKind::Int),
        CloseParen,
        Semicolon,
        If,
        OpenParen,
        Identifier,
        CloseParen,
        OpenBrace,
        Return,
        IntConstant(IntKind::Int),
        Semicolon,
        CloseBrace,
        Identifier,
        OpenParen,
        IntConstant(IntKind::Int),
        CloseParen,
        Semicolon,
        If,
        OpenParen,
        Identifier,
        BangEqual,
        IntConstant(IntKind::Int),
        CloseParen,
        OpenBrace,
        Return,
        IntConstant(IntKind::Int),
        Semicolon,
        CloseBrace,
        Identifier,
        OpenParen,
        CloseParen,
        Semicolon,
        Return,
        IntConstant(IntKind::Int),
        Semicolon,
        CloseBrace,
    ];
    assert_eq!(tokenize(src), expected);
}

#[test]
fn test_valid_void_pointer_array_of_pointers_to_void() {
    let src = r#"
        void *calloc(unsigned long nmemb, unsigned long size);
        void free(void *ptr);
        int main(void) {
            int i = 10;
            void *arr[4] = {
                calloc(2, sizeof(int)),
                &i,
                0,
                arr
            };
            long *l = arr[0];
            if (*l)
                return 1;
            int elem_1_val = *(int *)arr[1];
            if (elem_1_val != 10)
                return 2;
            if (arr[2])
                return 3;
            if (arr[3] != arr)
                return 4;
            free(arr[0]);
            return 0;
        }
    "#;
    let expected = vec![
        Void,
        Star,
        Identifier,
        OpenParen,
        Unsigned,
        Long,
        Identifier,
        Comma,
        Unsigned,
        Long,
        Identifier,
        CloseParen,
        Semicolon,
        Void,
        Identifier,
        OpenParen,
        Void,
        Star,
        Identifier,
        CloseParen,
        Semicolon,
        Int,
        Identifier,
        OpenParen,
        Void,
        CloseParen,
        OpenBrace,
        Int,
        Identifier,
        Equal,
        IntConstant(IntKind::Int),
        Semicolon,
        Void,
        Star,
        Identifier,
        OpenBracket,
        IntConstant(IntKind::Int),
        CloseBracket,
        Equal,
        OpenBrace,
        Identifier,
        OpenParen,
        IntConstant(IntKind::Int),
        Comma,
        Sizeof,
        OpenParen,
        Int,
        CloseParen,
        CloseParen,
        Comma,
        Ampersand,
        Identifier,
        Comma,
        IntConstant(IntKind::Int),
        Comma,
        Identifier,
        CloseBrace,
        Semicolon,
        Long,
        Star,
        Identifier,
        Equal,
        Identifier,
        OpenBracket,
        IntConstant(IntKind::Int),
        CloseBracket,
        Semicolon,
        If,
        OpenParen,
        Star,
        Identifier,
        CloseParen,
        Return,
        IntConstant(IntKind::Int),
        Semicolon,
        Int,
        Identifier,
        Equal,
        Star,
        OpenParen,
        Int,
        Star,
        CloseParen,
        Identifier,
        OpenBracket,
        IntConstant(IntKind::Int),
        CloseBracket,
        Semicolon,
        If,
        OpenParen,
        Identifier,
        BangEqual,
        IntConstant(IntKind::Int),
        CloseParen,
        Return,
        IntConstant(IntKind::Int),
        Semicolon,
        If,
        OpenParen,
        Identifier,
        OpenBracket,
        IntConstant(IntKind::Int),
        CloseBracket,
        CloseParen,
        Return,
        IntConstant(IntKind::Int),
        Semicolon,
        If,
        OpenParen,
        Identifier,
        OpenBracket,
        IntConstant(IntKind::Int),
        CloseBracket,
        BangEqual,
        Identifier,
        CloseParen,
        Return,
        IntConstant(IntKind::Int),
        Semicolon,
        Identifier,
        OpenParen,
        Identifier,
        OpenBracket,
        IntConstant(IntKind::Int),
        CloseBracket,
        CloseParen,
        Semicolon,
        Return,
        IntConstant(IntKind::Int),
        Semicolon,
        CloseBrace,
    ];
    assert_eq!(tokenize(src), expected);
}

#[test]
fn test_valid_void_pointer_common_pointer_type() {
    let src = r#"
        void *calloc(unsigned long nmemb, unsigned long size);
        void free(void *ptr);
        int main(void) {
            void *void_ptr = calloc(3, sizeof(unsigned int));
            unsigned int array[3] = {1, 2, 3};
            if (void_ptr == 0)
                return 1;
            if (void_ptr == array)
                return 2;
            if (!(void_ptr != array))
                return 3;
            static void *null_ptr = 0;
            int *my_array = null_ptr ? void_ptr : array;
            int array_element = my_array[1];
            if (array_element != 2) {
                return 4;
            }
            free(void_ptr);
            return 0;
        }
    "#;
    let expected = vec![
        Void,
        Star,
        Identifier,
        OpenParen,
        Unsigned,
        Long,
        Identifier,
        Comma,
        Unsigned,
        Long,
        Identifier,
        CloseParen,
        Semicolon,
        Void,
        Identifier,
        OpenParen,
        Void,
        Star,
        Identifier,
        CloseParen,
        Semicolon,
        Int,
        Identifier,
        OpenParen,
        Void,
        CloseParen,
        OpenBrace,
        Void,
        Star,
        Identifier,
        Equal,
        Identifier,
        OpenParen,
        IntConstant(IntKind::Int),
        Comma,
        Sizeof,
        OpenParen,
        Unsigned,
        Int,
        CloseParen,
        CloseParen,
        Semicolon,
        Unsigned,
        Int,
        Identifier,
        OpenBracket,
        IntConstant(IntKind::Int),
        CloseBracket,
        Equal,
        OpenBrace,
        IntConstant(IntKind::Int),
        Comma,
        IntConstant(IntKind::Int),
        Comma,
        IntConstant(IntKind::Int),
        CloseBrace,
        Semicolon,
        If,
        OpenParen,
        Identifier,
        EqualEqual,
        IntConstant(IntKind::Int),
        CloseParen,
        Return,
        IntConstant(IntKind::Int),
        Semicolon,
        If,
        OpenParen,
        Identifier,
        EqualEqual,
        Identifier,
        CloseParen,
        Return,
        IntConstant(IntKind::Int),
        Semicolon,
        If,
        OpenParen,
        Bang,
        OpenParen,
        Identifier,
        BangEqual,
        Identifier,
        CloseParen,
        CloseParen,
        Return,
        IntConstant(IntKind::Int),
        Semicolon,
        Static,
        Void,
        Star,
        Identifier,
        Equal,
        IntConstant(IntKind::Int),
        Semicolon,
        Int,
        Star,
        Identifier,
        Equal,
        Identifier,
        Question,
        Identifier,
        Colon,
        Identifier,
        Semicolon,
        Int,
        Identifier,
        Equal,
        Identifier,
        OpenBracket,
        IntConstant(IntKind::Int),
        CloseBracket,
        Semicolon,
        If,
        OpenParen,
        Identifier,
        BangEqual,
        IntConstant(IntKind::Int),
        CloseParen,
        OpenBrace,
        Return,
        IntConstant(IntKind::Int),
        Semicolon,
        CloseBrace,
        Identifier,
        OpenParen,
        Identifier,
        CloseParen,
        Semicolon,
        Return,
        IntConstant(IntKind::Int),
        Semicolon,
        CloseBrace,
    ];
    assert_eq!(tokenize(src), expected);
}

#[test]
fn test_valid_void_pointer_conversion_by_assignment() {
    let src = r#"
        void *malloc(unsigned long size);
        void free(void *ptr);
        int memcmp(void *s1, void *s2, unsigned long n);
        void *return_ptr(char *i) {
            return i + 3;
        }
        int check_char_ptr_argument(char *pointer, char expected_val) {
            return *pointer == expected_val;
        }
        int *return_void_ptr_as_int_ptr(void *pointer) {
            return pointer;
        }
        double *get_dbl_array(unsigned long n) {
            return (double *) malloc(n * sizeof (double));
        }
        void set_doubles(double *array, unsigned long n, double d) {
            for (unsigned long i = 0; i < n; i = i + 1) {
                array[i] = d;
            }
            return;
        }
        void *return_dbl_ptr_as_void_ptr(double *ptr) {
            return ptr;
        }
        int main(void) {
            void *four_bytes = malloc(4);
            int *int_ptr = four_bytes;
            *int_ptr = -1;
            if (!check_char_ptr_argument(four_bytes, -1)) {
                return 1;
            }
            if (return_void_ptr_as_int_ptr(four_bytes) != int_ptr) {
                return 2;
            }
            double *dbl_ptr = four_bytes;
            int (*complicated_ptr)[3][2][5] = four_bytes;
            long *long_ptr = four_bytes;
            if (dbl_ptr != four_bytes || complicated_ptr != four_bytes || long_ptr != four_bytes) {
                return 3;
            }
            free(four_bytes);
            double *dbl_array = get_dbl_array(5);
            void *void_array = dbl_array;
            set_doubles(void_array, 5, 4.0);
            if (dbl_array[3] != 4.0) {
                return 4;
            }
            if (return_dbl_ptr_as_void_ptr(dbl_array) != void_array) {
                return 5;
            }
            void *some_other_ptr = 0;
            some_other_ptr = dbl_array;
            if (some_other_ptr != void_array) {
                return 6;
            }
            some_other_ptr = &some_other_ptr;
            if (some_other_ptr == void_array) {
                return 7;
            }
            complicated_ptr = 0;
            some_other_ptr = complicated_ptr;
            if (some_other_ptr) {
                return 8;
            }
            free(dbl_array);
            long *long_ptr_array[3] = {
                malloc(sizeof(long)), malloc(sizeof(long)), malloc(sizeof(long))
            };
            *long_ptr_array[0] = 100l;
            *long_ptr_array[1] = 200l;
            *long_ptr_array[2] = 300l;
            long sum = (*long_ptr_array[0] + *long_ptr_array[1] + *long_ptr_array[2]);
            if (sum != 600l) {
                return 9;
            }
            free(long_ptr_array[0]);
            free(long_ptr_array[1]);
            free(long_ptr_array[2]);
            long arr1[3] = {1, 2, 3};
            long arr2[3] = {1, 2, 3};
            long arr3[3] = {1, 2, 4};
            if (memcmp(arr1, arr2, sizeof arr1) != 0) {
                return 10;
            }
            if (memcmp(arr1, arr3, sizeof arr2) != -1) {
                return 11;
            }
            return 0;
        }
    "#;
    let expected = vec![
        Void,
        Star,
        Identifier,
        OpenParen,
        Unsigned,
        Long,
        Identifier,
        CloseParen,
        Semicolon,
        Void,
        Identifier,
        OpenParen,
        Void,
        Star,
        Identifier,
        CloseParen,
        Semicolon,
        Int,
        Identifier,
        OpenParen,
        Void,
        Star,
        Identifier,
        Comma,
        Void,
        Star,
        Identifier,
        Comma,
        Unsigned,
        Long,
        Identifier,
        CloseParen,
        Semicolon,
        Void,
        Star,
        Identifier,
        OpenParen,
        Char,
        Star,
        Identifier,
        CloseParen,
        OpenBrace,
        Return,
        Identifier,
        Plus,
        IntConstant(IntKind::Int),
        Semicolon,
        CloseBrace,
        Int,
        Identifier,
        OpenParen,
        Char,
        Star,
        Identifier,
        Comma,
        Char,
        Identifier,
        CloseParen,
        OpenBrace,
        Return,
        Star,
        Identifier,
        EqualEqual,
        Identifier,
        Semicolon,
        CloseBrace,
        Int,
        Star,
        Identifier,
        OpenParen,
        Void,
        Star,
        Identifier,
        CloseParen,
        OpenBrace,
        Return,
        Identifier,
        Semicolon,
        CloseBrace,
        Double,
        Star,
        Identifier,
        OpenParen,
        Unsigned,
        Long,
        Identifier,
        CloseParen,
        OpenBrace,
        Return,
        OpenParen,
        Double,
        Star,
        CloseParen,
        Identifier,
        OpenParen,
        Identifier,
        Star,
        Sizeof,
        OpenParen,
        Double,
        CloseParen,
        CloseParen,
        Semicolon,
        CloseBrace,
        Void,
        Identifier,
        OpenParen,
        Double,
        Star,
        Identifier,
        Comma,
        Unsigned,
        Long,
        Identifier,
        Comma,
        Double,
        Identifier,
        CloseParen,
        OpenBrace,
        For,
        OpenParen,
        Unsigned,
        Long,
        Identifier,
        Equal,
        IntConstant(IntKind::Int),
        Semicolon,
        Identifier,
        Less,
        Identifier,
        Semicolon,
        Identifier,
        Equal,
        Identifier,
        Plus,
        IntConstant(IntKind::Int),
        CloseParen,
        OpenBrace,
        Identifier,
        OpenBracket,
        Identifier,
        CloseBracket,
        Equal,
        Identifier,
        Semicolon,
        CloseBrace,
        Return,
        Semicolon,
        CloseBrace,
        Void,
        Star,
        Identifier,
        OpenParen,
        Double,
        Star,
        Identifier,
        CloseParen,
        OpenBrace,
        Return,
        Identifier,
        Semicolon,
        CloseBrace,
        Int,
        Identifier,
        OpenParen,
        Void,
        CloseParen,
        OpenBrace,
        Void,
        Star,
        Identifier,
        Equal,
        Identifier,
        OpenParen,
        IntConstant(IntKind::Int),
        CloseParen,
        Semicolon,
        Int,
        Star,
        Identifier,
        Equal,
        Identifier,
        Semicolon,
        Star,
        Identifier,
        Equal,
        Minus,
        IntConstant(IntKind::Int),
        Semicolon,
        If,
        OpenParen,
        Bang,
        Identifier,
        OpenParen,
        Identifier,
        Comma,
        Minus,
        IntConstant(IntKind::Int),
        CloseParen,
        CloseParen,
        OpenBrace,
        Return,
        IntConstant(IntKind::Int),
        Semicolon,
        CloseBrace,
        If,
        OpenParen,
        Identifier,
        OpenParen,
        Identifier,
        CloseParen,
        BangEqual,
        Identifier,
        CloseParen,
        OpenBrace,
        Return,
        IntConstant(IntKind::Int),
        Semicolon,
        CloseBrace,
        Double,
        Star,
        Identifier,
        Equal,
        Identifier,
        Semicolon,
        Int,
        OpenParen,
        Star,
        Identifier,
        CloseParen,
        OpenBracket,
        IntConstant(IntKind::Int),
        CloseBracket,
        OpenBracket,
        IntConstant(IntKind::Int),
        CloseBracket,
        OpenBracket,
        IntConstant(IntKind::Int),
        CloseBracket,
        Equal,
        Identifier,
        Semicolon,
        Long,
        Star,
        Identifier,
        Equal,
        Identifier,
        Semicolon,
        If,
        OpenParen,
        Identifier,
        BangEqual,
        Identifier,
        PipePipe,
        Identifier,
        BangEqual,
        Identifier,
        PipePipe,
        Identifier,
        BangEqual,
        Identifier,
        CloseParen,
        OpenBrace,
        Return,
        IntConstant(IntKind::Int),
        Semicolon,
        CloseBrace,
        Identifier,
        OpenParen,
        Identifier,
        CloseParen,
        Semicolon,
        Double,
        Star,
        Identifier,
        Equal,
        Identifier,
        OpenParen,
        IntConstant(IntKind::Int),
        CloseParen,
        Semicolon,
        Void,
        Star,
        Identifier,
        Equal,
        Identifier,
        Semicolon,
        Identifier,
        OpenParen,
        Identifier,
        Comma,
        IntConstant(IntKind::Int),
        Comma,
        DoubleConstant,
        CloseParen,
        Semicolon,
        If,
        OpenParen,
        Identifier,
        OpenBracket,
        IntConstant(IntKind::Int),
        CloseBracket,
        BangEqual,
        DoubleConstant,
        CloseParen,
        OpenBrace,
        Return,
        IntConstant(IntKind::Int),
        Semicolon,
        CloseBrace,
        If,
        OpenParen,
        Identifier,
        OpenParen,
        Identifier,
        CloseParen,
        BangEqual,
        Identifier,
        CloseParen,
        OpenBrace,
        Return,
        IntConstant(IntKind::Int),
        Semicolon,
        CloseBrace,
        Void,
        Star,
        Identifier,
        Equal,
        IntConstant(IntKind::Int),
        Semicolon,
        Identifier,
        Equal,
        Identifier,
        Semicolon,
        If,
        OpenParen,
        Identifier,
        BangEqual,
        Identifier,
        CloseParen,
        OpenBrace,
        Return,
        IntConstant(IntKind::Int),
        Semicolon,
        CloseBrace,
        Identifier,
        Equal,
        Ampersand,
        Identifier,
        Semicolon,
        If,
        OpenParen,
        Identifier,
        EqualEqual,
        Identifier,
        CloseParen,
        OpenBrace,
        Return,
        IntConstant(IntKind::Int),
        Semicolon,
        CloseBrace,
        Identifier,
        Equal,
        IntConstant(IntKind::Int),
        Semicolon,
        Identifier,
        Equal,
        Identifier,
        Semicolon,
        If,
        OpenParen,
        Identifier,
        CloseParen,
        OpenBrace,
        Return,
        IntConstant(IntKind::Int),
        Semicolon,
        CloseBrace,
        Identifier,
        OpenParen,
        Identifier,
        CloseParen,
        Semicolon,
        Long,
        Star,
        Identifier,
        OpenBracket,
        IntConstant(IntKind::Int),
        CloseBracket,
        Equal,
        OpenBrace,
        Identifier,
        OpenParen,
        Sizeof,
        OpenParen,
        Long,
        CloseParen,
        CloseParen,
        Comma,
        Identifier,
        OpenParen,
        Sizeof,
        OpenParen,
        Long,
        CloseParen,
        CloseParen,
        Comma,
        Identifier,
        OpenParen,
        Sizeof,
        OpenParen,
        Long,
        CloseParen,
        CloseParen,
        CloseBrace,
        Semicolon,
        Star,
        Identifier,
        OpenBracket,
        IntConstant(IntKind::Int),
        CloseBracket,
        Equal,
        IntConstant(IntKind::Long),
        Semicolon,
        Star,
        Identifier,
        OpenBracket,
        IntConstant(IntKind::Int),
        CloseBracket,
        Equal,
        IntConstant(IntKind::Long),
        Semicolon,
        Star,
        Identifier,
        OpenBracket,
        IntConstant(IntKind::Int),
        CloseBracket,
        Equal,
        IntConstant(IntKind::Long),
        Semicolon,
        Long,
        Identifier,
        Equal,
        OpenParen,
        Star,
        Identifier,
        OpenBracket,
        IntConstant(IntKind::Int),
        CloseBracket,
        Plus,
        Star,
        Identifier,
        OpenBracket,
        IntConstant(IntKind::Int),
        CloseBracket,
        Plus,
        Star,
        Identifier,
        OpenBracket,
        IntConstant(IntKind::Int),
        CloseBracket,
        CloseParen,
        Semicolon,
        If,
        OpenParen,
        Identifier,
        BangEqual,
        IntConstant(IntKind::Long),
        CloseParen,
        OpenBrace,
        Return,
        IntConstant(IntKind::Int),
        Semicolon,
        CloseBrace,
        Identifier,
        OpenParen,
        Identifier,
        OpenBracket,
        IntConstant(IntKind::Int),
        CloseBracket,
        CloseParen,
        Semicolon,
        Identifier,
        OpenParen,
        Identifier,
        OpenBracket,
        IntConstant(IntKind::Int),
        CloseBracket,
        CloseParen,
        Semicolon,
        Identifier,
        OpenParen,
        Identifier,
        OpenBracket,
        IntConstant(IntKind::Int),
        CloseBracket,
        CloseParen,
        Semicolon,
        Long,
        Identifier,
        OpenBracket,
        IntConstant(IntKind::Int),
        CloseBracket,
        Equal,
        OpenBrace,
        IntConstant(IntKind::Int),
        Comma,
        IntConstant(IntKind::Int),
        Comma,
        IntConstant(IntKind::Int),
        CloseBrace,
        Semicolon,
        Long,
        Identifier,
        OpenBracket,
        IntConstant(IntKind::Int),
        CloseBracket,
        Equal,
        OpenBrace,
        IntConstant(IntKind::Int),
        Comma,
        IntConstant(IntKind::Int),
        Comma,
        IntConstant(IntKind::Int),
        CloseBrace,
        Semicolon,
        Long,
        Identifier,
        OpenBracket,
        IntConstant(IntKind::Int),
        CloseBracket,
        Equal,
        OpenBrace,
        IntConstant(IntKind::Int),
        Comma,
        IntConstant(IntKind::Int),
        Comma,
        IntConstant(IntKind::Int),
        CloseBrace,
        Semicolon,
        If,
        OpenParen,
        Identifier,
        OpenParen,
        Identifier,
        Comma,
        Identifier,
        Comma,
        Sizeof,
        Identifier,
        CloseParen,
        BangEqual,
        IntConstant(IntKind::Int),
        CloseParen,
        OpenBrace,
        Return,
        IntConstant(IntKind::Int),
        Semicolon,
        CloseBrace,
        If,
        OpenParen,
        Identifier,
        OpenParen,
        Identifier,
        Comma,
        Identifier,
        Comma,
        Sizeof,
        Identifier,
        CloseParen,
        BangEqual,
        Minus,
        IntConstant(IntKind::Int),
        CloseParen,
        OpenBrace,
        Return,
        IntConstant(IntKind::Int),
        Semicolon,
        CloseBrace,
        Return,
        IntConstant(IntKind::Int),
        Semicolon,
        CloseBrace,
    ];
    assert_eq!(tokenize(src), expected);
}

#[test]
fn test_valid_void_pointer_explicit_cast() {
    let src = r#"
        void *malloc(unsigned long size);
        void free(void *ptr);
        void *memcpy(void *s1, void *s2, unsigned long n);
        int main(void) {
            void *ptr = malloc(4 * sizeof(double));
            double *double_ptr = (double *)ptr;
            double_ptr[2] = 10.0;
            if ((void *)double_ptr != ptr) {
                return 1;
            }
            double result = double_ptr[2];
            if (result != 10.0) {
                return 2;
            }
            unsigned long ul = (unsigned long)ptr;
            if (ul % 8) {
                return 3;
            }
            free(ptr);
            long zero = 0;
            ptr = (void *) zero;
            if (ptr) {
                return 4;
            }
            zero = (long) ptr;
            if (zero) {
                return 5;
            }
            return 0;
        }
    "#;
    let expected = vec![
        Void,
        Star,
        Identifier,
        OpenParen,
        Unsigned,
        Long,
        Identifier,
        CloseParen,
        Semicolon,
        Void,
        Identifier,
        OpenParen,
        Void,
        Star,
        Identifier,
        CloseParen,
        Semicolon,
        Void,
        Star,
        Identifier,
        OpenParen,
        Void,
        Star,
        Identifier,
        Comma,
        Void,
        Star,
        Identifier,
        Comma,
        Unsigned,
        Long,
        Identifier,
        CloseParen,
        Semicolon,
        Int,
        Identifier,
        OpenParen,
        Void,
        CloseParen,
        OpenBrace,
        Void,
        Star,
        Identifier,
        Equal,
        Identifier,
        OpenParen,
        IntConstant(IntKind::Int),
        Star,
        Sizeof,
        OpenParen,
        Double,
        CloseParen,
        CloseParen,
        Semicolon,
        Double,
        Star,
        Identifier,
        Equal,
        OpenParen,
        Double,
        Star,
        CloseParen,
        Identifier,
        Semicolon,
        Identifier,
        OpenBracket,
        IntConstant(IntKind::Int),
        CloseBracket,
        Equal,
        DoubleConstant,
        Semicolon,
        If,
        OpenParen,
        OpenParen,
        Void,
        Star,
        CloseParen,
        Identifier,
        BangEqual,
        Identifier,
        CloseParen,
        OpenBrace,
        Return,
        IntConstant(IntKind::Int),
        Semicolon,
        CloseBrace,
        Double,
        Identifier,
        Equal,
        Identifier,
        OpenBracket,
        IntConstant(IntKind::Int),
        CloseBracket,
        Semicolon,
        If,
        OpenParen,
        Identifier,
        BangEqual,
        DoubleConstant,
        CloseParen,
        OpenBrace,
        Return,
        IntConstant(IntKind::Int),
        Semicolon,
        CloseBrace,
        Unsigned,
        Long,
        Identifier,
        Equal,
        OpenParen,
        Unsigned,
        Long,
        CloseParen,
        Identifier,
        Semicolon,
        If,
        OpenParen,
        Identifier,
        Percent,
        IntConstant(IntKind::Int),
        CloseParen,
        OpenBrace,
        Return,
        IntConstant(IntKind::Int),
        Semicolon,
        CloseBrace,
        Identifier,
        OpenParen,
        Identifier,
        CloseParen,
        Semicolon,
        Long,
        Identifier,
        Equal,
        IntConstant(IntKind::Int),
        Semicolon,
        Identifier,
        Equal,
        OpenParen,
        Void,
        Star,
        CloseParen,
        Identifier,
        Semicolon,
        If,
        OpenParen,
        Identifier,
        CloseParen,
        OpenBrace,
        Return,
        IntConstant(IntKind::Int),
        Semicolon,
        CloseBrace,
        Identifier,
        Equal,
        OpenParen,
        Long,
        CloseParen,
        Identifier,
        Semicolon,
        If,
        OpenParen,
        Identifier,
        CloseParen,
        OpenBrace,
        Return,
        IntConstant(IntKind::Int),
        Semicolon,
        CloseBrace,
        Return,
        IntConstant(IntKind::Int),
        Semicolon,
        CloseBrace,
    ];
    assert_eq!(tokenize(src), expected);
}

#[test]
fn test_valid_void_pointer_memory_management_functions() {
    let src = r#"
        void *malloc(unsigned long size);
        void *realloc(void *ptr, unsigned long size);
        void *calloc(unsigned long nmemb, unsigned long size);
        void *aligned_alloc(unsigned long alignment, unsigned long size);
        void free(void *ptr);
        int main(void) {
            char *char_buffer = malloc(50);
            for (int i = 0; i < 50; i = i + 1) {
                char_buffer[i] = i;
            }
            char *char_buffer2 = realloc(char_buffer, 100);
            char_buffer2[75] = 11;
            for (int i = 0; i < 50; i = i + 1) {
                if ( char_buffer2[i] != i) {
                    return 1;
                }
            }
            if (char_buffer2[75] != 11) {
                return 2;
            }
            free(char_buffer2);
            double *double_buffer = calloc(10, sizeof(double));
            for (int i = 0; i < 10; i = i + 1) {
                if (double_buffer[i]) {
                    return 3;
                }
            }
            free(double_buffer);
            char_buffer = aligned_alloc(256, 256);
            if ((unsigned long) char_buffer % 256) {
                return 4;
            }
            free(char_buffer);
            return 0;
        }
    "#;
    let expected = vec![
        Void,
        Star,
        Identifier,
        OpenParen,
        Unsigned,
        Long,
        Identifier,
        CloseParen,
        Semicolon,
        Void,
        Star,
        Identifier,
        OpenParen,
        Void,
        Star,
        Identifier,
        Comma,
        Unsigned,
        Long,
        Identifier,
        CloseParen,
        Semicolon,
        Void,
        Star,
        Identifier,
        OpenParen,
        Unsigned,
        Long,
        Identifier,
        Comma,
        Unsigned,
        Long,
        Identifier,
        CloseParen,
        Semicolon,
        Void,
        Star,
        Identifier,
        OpenParen,
        Unsigned,
        Long,
        Identifier,
        Comma,
        Unsigned,
        Long,
        Identifier,
        CloseParen,
        Semicolon,
        Void,
        Identifier,
        OpenParen,
        Void,
        Star,
        Identifier,
        CloseParen,
        Semicolon,
        Int,
        Identifier,
        OpenParen,
        Void,
        CloseParen,
        OpenBrace,
        Char,
        Star,
        Identifier,
        Equal,
        Identifier,
        OpenParen,
        IntConstant(IntKind::Int),
        CloseParen,
        Semicolon,
        For,
        OpenParen,
        Int,
        Identifier,
        Equal,
        IntConstant(IntKind::Int),
        Semicolon,
        Identifier,
        Less,
        IntConstant(IntKind::Int),
        Semicolon,
        Identifier,
        Equal,
        Identifier,
        Plus,
        IntConstant(IntKind::Int),
        CloseParen,
        OpenBrace,
        Identifier,
        OpenBracket,
        Identifier,
        CloseBracket,
        Equal,
        Identifier,
        Semicolon,
        CloseBrace,
        Char,
        Star,
        Identifier,
        Equal,
        Identifier,
        OpenParen,
        Identifier,
        Comma,
        IntConstant(IntKind::Int),
        CloseParen,
        Semicolon,
        Identifier,
        OpenBracket,
        IntConstant(IntKind::Int),
        CloseBracket,
        Equal,
        IntConstant(IntKind::Int),
        Semicolon,
        For,
        OpenParen,
        Int,
        Identifier,
        Equal,
        IntConstant(IntKind::Int),
        Semicolon,
        Identifier,
        Less,
        IntConstant(IntKind::Int),
        Semicolon,
        Identifier,
        Equal,
        Identifier,
        Plus,
        IntConstant(IntKind::Int),
        CloseParen,
        OpenBrace,
        If,
        OpenParen,
        Identifier,
        OpenBracket,
        Identifier,
        CloseBracket,
        BangEqual,
        Identifier,
        CloseParen,
        OpenBrace,
        Return,
        IntConstant(IntKind::Int),
        Semicolon,
        CloseBrace,
        CloseBrace,
        If,
        OpenParen,
        Identifier,
        OpenBracket,
        IntConstant(IntKind::Int),
        CloseBracket,
        BangEqual,
        IntConstant(IntKind::Int),
        CloseParen,
        OpenBrace,
        Return,
        IntConstant(IntKind::Int),
        Semicolon,
        CloseBrace,
        Identifier,
        OpenParen,
        Identifier,
        CloseParen,
        Semicolon,
        Double,
        Star,
        Identifier,
        Equal,
        Identifier,
        OpenParen,
        IntConstant(IntKind::Int),
        Comma,
        Sizeof,
        OpenParen,
        Double,
        CloseParen,
        CloseParen,
        Semicolon,
        For,
        OpenParen,
        Int,
        Identifier,
        Equal,
        IntConstant(IntKind::Int),
        Semicolon,
        Identifier,
        Less,
        IntConstant(IntKind::Int),
        Semicolon,
        Identifier,
        Equal,
        Identifier,
        Plus,
        IntConstant(IntKind::Int),
        CloseParen,
        OpenBrace,
        If,
        OpenParen,
        Identifier,
        OpenBracket,
        Identifier,
        CloseBracket,
        CloseParen,
        OpenBrace,
        Return,
        IntConstant(IntKind::Int),
        Semicolon,
        CloseBrace,
        CloseBrace,
        Identifier,
        OpenParen,
        Identifier,
        CloseParen,
        Semicolon,
        Identifier,
        Equal,
        Identifier,
        OpenParen,
        IntConstant(IntKind::Int),
        Comma,
        IntConstant(IntKind::Int),
        CloseParen,
        Semicolon,
        If,
        OpenParen,
        OpenParen,
        Unsigned,
        Long,
        CloseParen,
        Identifier,
        Percent,
        IntConstant(IntKind::Int),
        CloseParen,
        OpenBrace,
        Return,
        IntConstant(IntKind::Int),
        Semicolon,
        CloseBrace,
        Identifier,
        OpenParen,
        Identifier,
        CloseParen,
        Semicolon,
        Return,
        IntConstant(IntKind::Int),
        Semicolon,
        CloseBrace,
    ];
    assert_eq!(tokenize(src), expected);
}

#[test]
fn test_valid_void_pointer_simple() {
    let src = r#"
        void *malloc(unsigned long size);
        void free(void *ptr);
        int main(void) {
            int *array = malloc(10 * sizeof (int));
            array[2] = 100;
            int result = array[2];
            free(array);
            return result;
        }
    "#;
    let expected = vec![
        Void,
        Star,
        Identifier,
        OpenParen,
        Unsigned,
        Long,
        Identifier,
        CloseParen,
        Semicolon,
        Void,
        Identifier,
        OpenParen,
        Void,
        Star,
        Identifier,
        CloseParen,
        Semicolon,
        Int,
        Identifier,
        OpenParen,
        Void,
        CloseParen,
        OpenBrace,
        Int,
        Star,
        Identifier,
        Equal,
        Identifier,
        OpenParen,
        IntConstant(IntKind::Int),
        Star,
        Sizeof,
        OpenParen,
        Int,
        CloseParen,
        CloseParen,
        Semicolon,
        Identifier,
        OpenBracket,
        IntConstant(IntKind::Int),
        CloseBracket,
        Equal,
        IntConstant(IntKind::Int),
        Semicolon,
        Int,
        Identifier,
        Equal,
        Identifier,
        OpenBracket,
        IntConstant(IntKind::Int),
        CloseBracket,
        Semicolon,
        Identifier,
        OpenParen,
        Identifier,
        CloseParen,
        Semicolon,
        Return,
        Identifier,
        Semicolon,
        CloseBrace,
    ];
    assert_eq!(tokenize(src), expected);
}
